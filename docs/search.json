[
  {
    "objectID": "programming/Jacobian-adjustment-normal/understanding-jacobian-adjustment.html",
    "href": "programming/Jacobian-adjustment-normal/understanding-jacobian-adjustment.html",
    "title": "Understanding Jacobian Adjustments for Constrained Parameters in Stan",
    "section": "",
    "text": "Probability masses of normal and lognormal distributions within the corresponding intervals\n\n\n\n\nThe Jacobian adjustment is a key concept in statistical modeling that arises when transforming probability distributions from one space to another. The intuition is that when you change a random variable, you‚Äôre not just changing the values - you‚Äôre also changing how ‚Äústretched‚Äù or ‚Äúcompressed‚Äù the probability density becomes at different points. To account for the distortion caused by the transform, the density must be multiplied by a Jacobian adjustment. This ensures that probability masses of corresponding intervals stay unchanged before and after the transform. This is illustrated by the figure above, which compares the probability density functions of a standard normal distribution and its transformed lognormal distribution. Although the shapes of the two distributions differ, the transformation must preserve the probability mass over corresponding intervals.\nIn Bayesian inference, Jacobian adjustments are especially important when transforming parameters from a constrained space (e.g., the positive real line) to an unconstrained space (e.g., the entire real line), which is commonly done to improve sampling efficiency and numerical stability. In Stan, such transformations are typically handled automatically. When you declare a constrained parameter (e.g., &lt;lower=0&gt;), Stan internally transforms it to an unconstrained space and applies the appropriate Jacobian adjustment to maintain the correct posterior density.\nHowever, if you manually transform variables inside the transformed parameters block and assign priors to the transformed variables, you need to explicitly include the Jacobian adjustment to preserve the correct log posterior density (lp__). Failing to do so can lead to biased inference. To illustrate how this works, I‚Äôll use a simple example of normal distribution, focusing on how Stan handles transformations of the standard deviation parameter \\(\\sigma\\) (i.e., &lt;lower=0&gt;) and how we can include a manual Jacobian adjustment.\n\n\nI will first simulate some data from a normal distribution with mean 0 and standard deviation 20. A large standard deviation is chosen to make the effect of Jacobian adjustment more pronounced.\n\ndata_norm &lt;- list(N = 100, y = rnorm(100, 0, 20))\n\n\n\n\nI will include four models to compare posterior parameter estimates and the log posterior density (lp__). The models are:\nModel 1: A normal distribution with a proper constraint on \\(\\sigma\\) Model 2: A normal distribution without a constraint on \\(\\sigma\\) Model 3: A normal distribution with an exponential transformation of unconstrained \\(\\sigma_z\\) and a Jacobian adjustment Model 4: A normal distribution with transformation of \\(\\sigma\\) in the transformed parameters block (No Jacobian needed!)\n\n\nThe first model is a simple normal distribution with a proper constraint on \\(\\sigma\\) (&lt;lower=0&gt;). According to Stan reference manual, to avoid having to deal with constraints while simulating the Hamiltonian dynamics during sampling, every (multivariate) parameter in a Stan model is transformed to an unconstrained variable behind the scenes by the model compiler, and Stan handles the Jacobian adjustment automatically.\ndata {\n  int&lt;lower=0&gt; N; // number of observations\n  vector[N] y; // observed data\n}\n\nparameters {\n  real mu; // mean parameter\n  real&lt;lower=0&gt; sigma; // standard deviation parameter\n}\n\nmodel {\n  // Priors\n  target += normal_lpdf(mu | 0, 10); // prior for mean\n  target += normal_lpdf(sigma | 0, 5); // prior for standard deviation\n  \n  // Likelihood\n  target += normal_lpdf(y | mu, sigma); // data follows normal distribution\n}\n\nmd_norm &lt;- stan_model(file = \"./Models/normal.stan\")\nfit_norm &lt;- sampling(md_norm, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nNow we turn to another model by removing the constraint on \\(\\sigma\\). In this case, the parameter \\(\\sigma\\) is not a constrained variable, and there is no Jacobian adjustment handled by Stan. This means that the log posterior density (lp__) is biased.\ndata {\n  int&lt;lower=0&gt; N; // number of observations\n  vector[N] y; // observed data\n}\n\nparameters {\n  real mu; // mean parameter\n  real sigma; // standard deviation parameter\n}\nmodel {\n  // Priors\n  target += normal_lpdf(mu | 0, 10); // prior for mean\n  target += normal_lpdf(sigma | 0, 5); // prior for standard deviation\n  \n  // Likelihood\n  target += normal_lpdf(y | mu, sigma); // data follows normal distribution\n}\n\nmd_norm_no_constraint &lt;- stan_model(file = \"./Models/normal_no_constraint_sigma.stan\")\nfit_norm_no_constraint &lt;- sampling(md_norm_no_constraint, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_no_constraint, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nAs a comparison, we can also reformulate the model by defining the parameter \\(\\sigma_z\\) as an unconstrained variable, and we then transform it via an exponential function (positive real line). The transformed variable \\(\\sigma\\) will be assigned with a prior and used in the model. This is exactly what has happened internally by Stan when you define a parameter with a proper constraint (e.g., &lt;lower=0&gt; for \\(\\sigma\\)). Stan handles the transformation from an unconstrained internal representation to this constrained user-facing value. Since \\(\\sigma\\) is transformed from \\(\\sigma_z\\), we need to include a Jacobian adjustment to preserve the correct log posterior density (lp__).\n\nLet me explain how the Jacobian adjustment works step by step.\nLet: \\[y = \\sigma_e, \\quad x = \\sigma, \\quad y = \\exp(x)\\]\nWe are transforming from an unconstrained variable \\(x \\in \\mathbb{R}\\) to a positive variable \\(y \\in (0, \\infty)\\).\nNext, we can compute the derivative: \\[\\frac{dy}{dx} = \\frac{d}{dx} \\exp(x) = \\exp(x) = y\\]\nWe apply the change-of-variables formula for densities: \\[\\left|f_Y(y) \\cdot dy\\right| = \\left|f_X(x) \\cdot dx\\right|\n\\quad \\Rightarrow \\quad\nf_Y(y) \\cdot \\left| \\frac{dy}{dx} \\right| = f_X(x)\\]\nSubstituting \\(\\frac{dy}{dx} = y\\), we get: \\[f_Y(y) \\cdot y = f_X(x)\\]\nTaking logs to get log-densities: \\[\\log f_X(x) = \\log f_Y(y) + \\log y\\]\nThis extra term \\(\\log y\\) is the Jacobian adjustment.\nIn Stan notation, we get:\n\\[\\text{target} ~ \\text{+=} ~ \\text{normal\\_lpdf}(\\mu, \\exp(\\sigma_e)) + \\log(\\sigma_e)\\]\n\ndata {\n  int&lt;lower=0&gt; N; // number of observations\n  vector[N] y; // observed data\n}\nparameters {\n  real mu; // mean parameter\n  real sigma_z; // unconstrained standard deviation parameter\n}\ntransformed parameters {\n  real sigma = exp(sigma_z);\n}\nmodel {\n  // Method 1: prior on sigma, with transformed block and Jacobian adjustment\n  target += normal_lpdf(sigma | 0, 5); // prior for the transformed standard deviation\n\n  // Method 2: local variable sigma, no transformed block, but with Jacobian adjustment\n  // real sigma = exp(sigma_z);\n  // target += normal_lpdf(sigma | 0, 5); // prior for the transformed standard deviation\n\n  target += normal_lpdf(mu | 0, 10); // prior for mean\n  \n  // Likelihood\n  target += normal_lpdf(y | mu, sigma) + log(sigma); // add Jacobian adjustment\n  // target += normal_lpdf(y | mu, sigma) + sigma_z; // alternatively\n}\n\n\nmd_norm_exp_jacobian &lt;- stan_model(file = \"./Models/normal_exp_sigma_jacobian.stan\")\nfit_norm_exp_jacobian &lt;- sampling(md_norm_exp_jacobian, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_exp_jacobian, pars = c(\"mu\", \"lp__\"))\nprint(fit_norm_exp_jacobian, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nIt is also worth mentioning that if you transform the parameter \\(\\sigma\\) in the transformed parameters block without assigning a prior to the transformed parameter, you do not need to include a Jacobian adjustment. This is because the transformation is applied to the parameter after sampling. This is conceptually similar to generating quantities from posterior draws.\nAs a general rule, if you place priors on the declared parameters or directly use the parameters inside parameters block (in most cases), rather than on transformed parameters, no Jacobian adjustment is needed‚Äîthis is a simple variable transformation. By contrast, if you transform a parameter and place a prior on the transformed variable, you need to include a Jacobian adjustment.\ndata {\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n}\nparameters {\n  real mu;\n  real&lt;lower=0&gt; sigma;\n} \ntransformed parameters {\n  // Method 1: simple transformation without a prior for the transformed parameter\n  real log_sigma = log(sigma); \n}\nmodel {\n  // Priors\n  target += normal_lpdf(mu | 0, 10);\n  target += normal_lpdf(sigma | 0, 5); // prior on sigma\n\n  // Likelihood\n  target += normal_lpdf(y | mu, sigma);\n}\n\nmd_norm_transform_parameters &lt;- stan_model(file = \"./Models/normal_transform_parameters.stan\")\nfit_norm_transform_parameters &lt;- sampling(md_norm_transform_parameters, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_transform_parameters, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nYou may think of it in a different way by transforming the parameter \\(\\sigma\\) via logrithm transformation. This is not what happened under the hood in stan, since Jacobian adjustment is performed on the absolute derivative of the inverse transform. See the stan reference manual for more details.\n\nUnivariate changes of variables Suppose \\(X\\) is one dimensional and \\(f : \\mathrm{supp}(X) \\to \\mathbb{R}\\) is a one-to-one, monotonic function with a differentiable inverse \\(f^{-1}\\). Then the density of \\(Y\\) is given by\n\\[p_Y(y) = p_X(f^{-1}(y)) \\left| \\frac{d}{dy} f^{-1}(y) \\right|\\]\nThe absolute derivative of the inverse transform measures how the scale of the transformed variable changes with respect to the underlying variable.\n\nIf you change in this way, you will change the prior on \\(\\sigma\\). You will not get the same log posterior density (lp__) as Model 1, since the prior on \\(\\sigma\\) is different.\nIn model 1: \\(\\sigma \\sim \\mathcal{N}(0, 5)\\)\nIn model 5: \\(\\log(\\sigma) \\sim \\mathcal{N}(0, 5)\\) or \\(\\sigma \\sim \\mathcal{LogN}(0, 5)\\)\nMy own opinion is that it is not recommended to transform the parameter locally inside the model block, since (1) it is not that transparent unless you really know what you are doing and (2) it will not be saved in the output.\ndata {\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n}\nparameters {\n  real mu;\n  real&lt;lower=0&gt; sigma;\n}\nmodel {\n  // Method 1: prior on log(sigma) --&gt; lead to a different prior on sigma\n  target += normal_lpdf(log(sigma) | 0, 5);\n  target += lognormal_lpdf(sigma | 0, 5); // equivalently\n\n  // Method 2: prior on local variable sigma_log with Jacobian adjustment\n  // real sigma_log = log(sigma);\n  // target += normal_lpdf(sigma_log | 0, 5);\n\n  // Priors\n  target += normal_lpdf(mu | 0, 10);\n\n  // Likelihood\n  target += normal_lpdf(y | mu, sigma);\n}\n\nmd_norm_transform_local &lt;- stan_model(file = \"./Models/normal_transform_local.stan\")\nfit_norm_transform_local &lt;- sampling(md_norm_transform_local, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_transform_local, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nAs we can see, the posterior parameter estimates for \\(\\mu\\) and \\(\\sigma\\) are similar across all three models. However, the log posterior density (lp__) differs between Model 1 and Model 2. This is because Model 1 includes the proper constraint on \\(\\sigma\\), while Model 2 does not. The log posterior density in Model 2 is biased due to the missing Jacobian adjustment. Model 3 addresses this issue by including a Jacobian adjustment. In general, if you are interested in parameter inference, it may be not a major concern in this case, but missing Jacobian adjustments can cause serious problems for model comparison (e.g., WAIC, LOO, and Bayes factors).\nNote that this example is only for illustration and help you understand the concept of Jacobian adjustment and how Stan handles changes of variables. In practice, you should always use the proper constraint on the parameter and let Stan handle the Jacobian adjustment automatically, which is both more efficient and more reliable.\nRelated links\n\n(Best) A coin toss example with Jacobian transformation\nThe Jacobian transformation\nChanges of variables\nTransforms\nLaplace method and Jacobian of parameter transformation"
  },
  {
    "objectID": "programming/Jacobian-adjustment-normal/understanding-jacobian-adjustment.html#simulate-data",
    "href": "programming/Jacobian-adjustment-normal/understanding-jacobian-adjustment.html#simulate-data",
    "title": "Understanding Jacobian Adjustments for Constrained Parameters in Stan",
    "section": "",
    "text": "I will first simulate some data from a normal distribution with mean 0 and standard deviation 20. A large standard deviation is chosen to make the effect of Jacobian adjustment more pronounced.\n\ndata_norm &lt;- list(N = 100, y = rnorm(100, 0, 20))"
  },
  {
    "objectID": "programming/Jacobian-adjustment-normal/understanding-jacobian-adjustment.html#posterior-parameter-estimates",
    "href": "programming/Jacobian-adjustment-normal/understanding-jacobian-adjustment.html#posterior-parameter-estimates",
    "title": "Understanding Jacobian Adjustments for Constrained Parameters in Stan",
    "section": "",
    "text": "I will include four models to compare posterior parameter estimates and the log posterior density (lp__). The models are:\nModel 1: A normal distribution with a proper constraint on \\(\\sigma\\) Model 2: A normal distribution without a constraint on \\(\\sigma\\) Model 3: A normal distribution with an exponential transformation of unconstrained \\(\\sigma_z\\) and a Jacobian adjustment Model 4: A normal distribution with transformation of \\(\\sigma\\) in the transformed parameters block (No Jacobian needed!)\n\n\nThe first model is a simple normal distribution with a proper constraint on \\(\\sigma\\) (&lt;lower=0&gt;). According to Stan reference manual, to avoid having to deal with constraints while simulating the Hamiltonian dynamics during sampling, every (multivariate) parameter in a Stan model is transformed to an unconstrained variable behind the scenes by the model compiler, and Stan handles the Jacobian adjustment automatically.\ndata {\n  int&lt;lower=0&gt; N; // number of observations\n  vector[N] y; // observed data\n}\n\nparameters {\n  real mu; // mean parameter\n  real&lt;lower=0&gt; sigma; // standard deviation parameter\n}\n\nmodel {\n  // Priors\n  target += normal_lpdf(mu | 0, 10); // prior for mean\n  target += normal_lpdf(sigma | 0, 5); // prior for standard deviation\n  \n  // Likelihood\n  target += normal_lpdf(y | mu, sigma); // data follows normal distribution\n}\n\nmd_norm &lt;- stan_model(file = \"./Models/normal.stan\")\nfit_norm &lt;- sampling(md_norm, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nNow we turn to another model by removing the constraint on \\(\\sigma\\). In this case, the parameter \\(\\sigma\\) is not a constrained variable, and there is no Jacobian adjustment handled by Stan. This means that the log posterior density (lp__) is biased.\ndata {\n  int&lt;lower=0&gt; N; // number of observations\n  vector[N] y; // observed data\n}\n\nparameters {\n  real mu; // mean parameter\n  real sigma; // standard deviation parameter\n}\nmodel {\n  // Priors\n  target += normal_lpdf(mu | 0, 10); // prior for mean\n  target += normal_lpdf(sigma | 0, 5); // prior for standard deviation\n  \n  // Likelihood\n  target += normal_lpdf(y | mu, sigma); // data follows normal distribution\n}\n\nmd_norm_no_constraint &lt;- stan_model(file = \"./Models/normal_no_constraint_sigma.stan\")\nfit_norm_no_constraint &lt;- sampling(md_norm_no_constraint, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_no_constraint, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nAs a comparison, we can also reformulate the model by defining the parameter \\(\\sigma_z\\) as an unconstrained variable, and we then transform it via an exponential function (positive real line). The transformed variable \\(\\sigma\\) will be assigned with a prior and used in the model. This is exactly what has happened internally by Stan when you define a parameter with a proper constraint (e.g., &lt;lower=0&gt; for \\(\\sigma\\)). Stan handles the transformation from an unconstrained internal representation to this constrained user-facing value. Since \\(\\sigma\\) is transformed from \\(\\sigma_z\\), we need to include a Jacobian adjustment to preserve the correct log posterior density (lp__).\n\nLet me explain how the Jacobian adjustment works step by step.\nLet: \\[y = \\sigma_e, \\quad x = \\sigma, \\quad y = \\exp(x)\\]\nWe are transforming from an unconstrained variable \\(x \\in \\mathbb{R}\\) to a positive variable \\(y \\in (0, \\infty)\\).\nNext, we can compute the derivative: \\[\\frac{dy}{dx} = \\frac{d}{dx} \\exp(x) = \\exp(x) = y\\]\nWe apply the change-of-variables formula for densities: \\[\\left|f_Y(y) \\cdot dy\\right| = \\left|f_X(x) \\cdot dx\\right|\n\\quad \\Rightarrow \\quad\nf_Y(y) \\cdot \\left| \\frac{dy}{dx} \\right| = f_X(x)\\]\nSubstituting \\(\\frac{dy}{dx} = y\\), we get: \\[f_Y(y) \\cdot y = f_X(x)\\]\nTaking logs to get log-densities: \\[\\log f_X(x) = \\log f_Y(y) + \\log y\\]\nThis extra term \\(\\log y\\) is the Jacobian adjustment.\nIn Stan notation, we get:\n\\[\\text{target} ~ \\text{+=} ~ \\text{normal\\_lpdf}(\\mu, \\exp(\\sigma_e)) + \\log(\\sigma_e)\\]\n\ndata {\n  int&lt;lower=0&gt; N; // number of observations\n  vector[N] y; // observed data\n}\nparameters {\n  real mu; // mean parameter\n  real sigma_z; // unconstrained standard deviation parameter\n}\ntransformed parameters {\n  real sigma = exp(sigma_z);\n}\nmodel {\n  // Method 1: prior on sigma, with transformed block and Jacobian adjustment\n  target += normal_lpdf(sigma | 0, 5); // prior for the transformed standard deviation\n\n  // Method 2: local variable sigma, no transformed block, but with Jacobian adjustment\n  // real sigma = exp(sigma_z);\n  // target += normal_lpdf(sigma | 0, 5); // prior for the transformed standard deviation\n\n  target += normal_lpdf(mu | 0, 10); // prior for mean\n  \n  // Likelihood\n  target += normal_lpdf(y | mu, sigma) + log(sigma); // add Jacobian adjustment\n  // target += normal_lpdf(y | mu, sigma) + sigma_z; // alternatively\n}\n\n\nmd_norm_exp_jacobian &lt;- stan_model(file = \"./Models/normal_exp_sigma_jacobian.stan\")\nfit_norm_exp_jacobian &lt;- sampling(md_norm_exp_jacobian, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_exp_jacobian, pars = c(\"mu\", \"lp__\"))\nprint(fit_norm_exp_jacobian, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nIt is also worth mentioning that if you transform the parameter \\(\\sigma\\) in the transformed parameters block without assigning a prior to the transformed parameter, you do not need to include a Jacobian adjustment. This is because the transformation is applied to the parameter after sampling. This is conceptually similar to generating quantities from posterior draws.\nAs a general rule, if you place priors on the declared parameters or directly use the parameters inside parameters block (in most cases), rather than on transformed parameters, no Jacobian adjustment is needed‚Äîthis is a simple variable transformation. By contrast, if you transform a parameter and place a prior on the transformed variable, you need to include a Jacobian adjustment.\ndata {\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n}\nparameters {\n  real mu;\n  real&lt;lower=0&gt; sigma;\n} \ntransformed parameters {\n  // Method 1: simple transformation without a prior for the transformed parameter\n  real log_sigma = log(sigma); \n}\nmodel {\n  // Priors\n  target += normal_lpdf(mu | 0, 10);\n  target += normal_lpdf(sigma | 0, 5); // prior on sigma\n\n  // Likelihood\n  target += normal_lpdf(y | mu, sigma);\n}\n\nmd_norm_transform_parameters &lt;- stan_model(file = \"./Models/normal_transform_parameters.stan\")\nfit_norm_transform_parameters &lt;- sampling(md_norm_transform_parameters, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_transform_parameters, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nYou may think of it in a different way by transforming the parameter \\(\\sigma\\) via logrithm transformation. This is not what happened under the hood in stan, since Jacobian adjustment is performed on the absolute derivative of the inverse transform. See the stan reference manual for more details.\n\nUnivariate changes of variables Suppose \\(X\\) is one dimensional and \\(f : \\mathrm{supp}(X) \\to \\mathbb{R}\\) is a one-to-one, monotonic function with a differentiable inverse \\(f^{-1}\\). Then the density of \\(Y\\) is given by\n\\[p_Y(y) = p_X(f^{-1}(y)) \\left| \\frac{d}{dy} f^{-1}(y) \\right|\\]\nThe absolute derivative of the inverse transform measures how the scale of the transformed variable changes with respect to the underlying variable.\n\nIf you change in this way, you will change the prior on \\(\\sigma\\). You will not get the same log posterior density (lp__) as Model 1, since the prior on \\(\\sigma\\) is different.\nIn model 1: \\(\\sigma \\sim \\mathcal{N}(0, 5)\\)\nIn model 5: \\(\\log(\\sigma) \\sim \\mathcal{N}(0, 5)\\) or \\(\\sigma \\sim \\mathcal{LogN}(0, 5)\\)\nMy own opinion is that it is not recommended to transform the parameter locally inside the model block, since (1) it is not that transparent unless you really know what you are doing and (2) it will not be saved in the output.\ndata {\n  int&lt;lower=0&gt; N;\n  vector[N] y;\n}\nparameters {\n  real mu;\n  real&lt;lower=0&gt; sigma;\n}\nmodel {\n  // Method 1: prior on log(sigma) --&gt; lead to a different prior on sigma\n  target += normal_lpdf(log(sigma) | 0, 5);\n  target += lognormal_lpdf(sigma | 0, 5); // equivalently\n\n  // Method 2: prior on local variable sigma_log with Jacobian adjustment\n  // real sigma_log = log(sigma);\n  // target += normal_lpdf(sigma_log | 0, 5);\n\n  // Priors\n  target += normal_lpdf(mu | 0, 10);\n\n  // Likelihood\n  target += normal_lpdf(y | mu, sigma);\n}\n\nmd_norm_transform_local &lt;- stan_model(file = \"./Models/normal_transform_local.stan\")\nfit_norm_transform_local &lt;- sampling(md_norm_transform_local, data_norm,\n  iter = 2000, chains = 1\n)\nprint(fit_norm_transform_local, pars = c(\"mu\", \"sigma\", \"lp__\"))\n\n\n\n\nAs we can see, the posterior parameter estimates for \\(\\mu\\) and \\(\\sigma\\) are similar across all three models. However, the log posterior density (lp__) differs between Model 1 and Model 2. This is because Model 1 includes the proper constraint on \\(\\sigma\\), while Model 2 does not. The log posterior density in Model 2 is biased due to the missing Jacobian adjustment. Model 3 addresses this issue by including a Jacobian adjustment. In general, if you are interested in parameter inference, it may be not a major concern in this case, but missing Jacobian adjustments can cause serious problems for model comparison (e.g., WAIC, LOO, and Bayes factors).\nNote that this example is only for illustration and help you understand the concept of Jacobian adjustment and how Stan handles changes of variables. In practice, you should always use the proper constraint on the parameter and let Stan handle the Jacobian adjustment automatically, which is both more efficient and more reliable.\nRelated links\n\n(Best) A coin toss example with Jacobian transformation\nThe Jacobian transformation\nChanges of variables\nTransforms\nLaplace method and Jacobian of parameter transformation"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Data Science Toolkit",
    "section": "",
    "text": "Data Science Toolkit aims to provide comprehensive, practical resources for learners and practitioners. I believe that the right tools and knowledge should be accessible to everyone interested in learning to become a data scientist."
  },
  {
    "objectID": "about.html#our-mission",
    "href": "about.html#our-mission",
    "title": "About Data Science Toolkit",
    "section": "",
    "text": "Data Science Toolkit aims to provide comprehensive, practical resources for learners and practitioners. I believe that the right tools and knowledge should be accessible to everyone interested in learning to become a data scientist."
  },
  {
    "objectID": "commandline/ghostty-yazi-terminal/ghostty-yazi.html",
    "href": "commandline/ghostty-yazi-terminal/ghostty-yazi.html",
    "title": "Transform Your Terminal with Ghostty and Yazi",
    "section": "",
    "text": "Why I Switched from Kitty and Vifm to Ghostty and Yazi? After years of experimenting with different terminal emulators and file managers, I‚Äôve finally found my favorite combination: Ghostty and Yazi. These have recently gained a lot of popularity in the community. Briefly put, Ghostty is a modern terminal emulator that is fast, feature-rich, and native. Yazi is a blazing-fast terminal file manager. Together, they have transformed my daily workflow. In this blog, I‚Äôll show you how to set them up on your own computer, so you can supercharge your terminal experience just like I did.\nNote: here I assume the default fish shell is used. You can install it in this blog."
  },
  {
    "objectID": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#brew-install-ghostty",
    "href": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#brew-install-ghostty",
    "title": "Transform Your Terminal with Ghostty and Yazi",
    "section": "2.1 brew install ghostty",
    "text": "2.1 brew install ghostty\nbrew install --cask ghostty"
  },
  {
    "objectID": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#set-ghostty-as-default-terminal-emulator-on-mac",
    "href": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#set-ghostty-as-default-terminal-emulator-on-mac",
    "title": "Transform Your Terminal with Ghostty and Yazi",
    "section": "2.2 set ghostty as default terminal emulator on mac",
    "text": "2.2 set ghostty as default terminal emulator on mac\n\n\nInstall the ‚ÄúRCDefaultApp.prefPane‚Äù plugin\n\n\nThis plugin is used to set the default app for opening terminal in your system.\ngit clone https://github.com/JakeJing/fishconfig.git\nsudo mv fishconfig/kitty/RCDefaultApp.prefPane /Library/PreferencePanes/\n\n\nSet ghostty as the ‚Äúdefault app‚Äù for opening terminal\n\n\nGo to system preferences -&gt; default Apps -&gt; click the ‚Äúdefault Apps‚Äù -&gt; URLS -&gt; x-man-page -&gt; set the default application as ‚Äúghostty‚Äù.\n\n\n\nSet ghostty as default app for opening terminal\n\n\n\n\nAdd keyboard shortcut (shift-cmd-1) to open a new Ghostty window here\n\n\nYou can set a keyboard shortcut to open Ghostty here. However, the default option only works when your cursor is on a folder. To enable it when your cursor is on a file, you can create a new service using the Automator application. To do this, go to Automator -&gt; Quick Action, and follow the steps in the image below.\n\n\n\nAutomator Quick Action\n\n\nAfter that, you can go to System Preferences -&gt; Keyboard -&gt; Shortcuts -&gt; Services -&gt; open-ghostty-here to add it (shift-cmd-1).\n\n\n\n\nAdd keyboard shortcut to open Ghostty here\n\n\nThis will automatically open a new Ghostty window here when you press shift-cmd-1. If there is an ongoing Ghostty window, it will open a new tab instead. So far there is no easy way to always open a new window (rather than a new tab or a new process) on mac, as far as I know.\n# check the services\nls ~/Library/Services/\n\n\nadd configuration file for ghostty\n\n\nwget https://raw.githubusercontent.com/JakeJing/dotfiles/refs/heads/main/.config/ghostty/config -P ~/.config/ghostty/"
  },
  {
    "objectID": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#brew-install-yazi-and-its-dependencies",
    "href": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#brew-install-yazi-and-its-dependencies",
    "title": "Transform Your Terminal with Ghostty and Yazi",
    "section": "3.1 brew install yazi and its dependencies",
    "text": "3.1 brew install yazi and its dependencies\nbrew update\nbrew install yazi ffmpeg sevenzip jq poppler fd ripgrep fzf zoxide resvg imagemagick font-symbols-only-nerd-font"
  },
  {
    "objectID": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#set-alias-in-fish-config",
    "href": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#set-alias-in-fish-config",
    "title": "Transform Your Terminal with Ghostty and Yazi",
    "section": "3.2 set alias in fish config",
    "text": "3.2 set alias in fish config\n# yazi\nalias yz yazi\nalias y yazi\nalias a yazi"
  },
  {
    "objectID": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#add-configuration-file-and-keymap-for-yazi",
    "href": "commandline/ghostty-yazi-terminal/ghostty-yazi.html#add-configuration-file-and-keymap-for-yazi",
    "title": "Transform Your Terminal with Ghostty and Yazi",
    "section": "3.3 add configuration file and keymap for yazi",
    "text": "3.3 add configuration file and keymap for yazi\n# clone my dotfiles\ngit clone https://github.com/JakeJing/dotfiles.git\n# move yazi config\nmv dotfiles/.config/yazi -P ~/.config/yazi/\n\n\n\nUseful Yazi Keybindings"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to Data Science Toolkit",
    "section": "",
    "text": "Curated collections of programming languages for specific data science tasks:\n\nüß™ R Ecosystem: Tidyverse, and statistical packages\nüìà Stan: Bayesian analysis, Probabilistic programming\nüé® Data Visualization: ggplot2, Plotly\n\n\n\n\nStep-by-step guides and hands-on examples:\n\nüßÆ Ghostty / Kitty\nüóÇÔ∏è Yazi / Vifm\nüìä Visidata\n\n\n\n\nAdditional learning materials:\n\nüìñ Recommended Books and Courses\nüìÇ Datasets for Practice\nüåê Community Resources"
  },
  {
    "objectID": "index.html#what-youll-find-here",
    "href": "index.html#what-youll-find-here",
    "title": "Welcome to Data Science Toolkit",
    "section": "",
    "text": "Curated collections of programming languages for specific data science tasks:\n\nüß™ R Ecosystem: Tidyverse, and statistical packages\nüìà Stan: Bayesian analysis, Probabilistic programming\nüé® Data Visualization: ggplot2, Plotly\n\n\n\n\nStep-by-step guides and hands-on examples:\n\nüßÆ Ghostty / Kitty\nüóÇÔ∏è Yazi / Vifm\nüìä Visidata\n\n\n\n\nAdditional learning materials:\n\nüìñ Recommended Books and Courses\nüìÇ Datasets for Practice\nüåê Community Resources"
  },
  {
    "objectID": "commandline/essential-helix-commands/essential-helix.html",
    "href": "commandline/essential-helix-commands/essential-helix.html",
    "title": "Essential Helix Commands",
    "section": "",
    "text": "Note: In Helix, Alt (or A) functions similarly to Cmd in Vim. Importantly, Helix uses a selection-first model‚Äîyou must select text before performing most actions.\n\n1 Navigation\n\nh / j / k / l: Move left, down, up, right\nw / W / e / E / b / B: Word-based motion\ni / a / I / A: Insert modes at various positions\nf / F / t / T: Jump to characters in the current line\ngg: Go to beginning of file\nge: Go to end of file\ngh: Go to beginning of line\ngl: Go to end of line\nu / U: Undo / redo\ngr: Go to reference\ngd: Go to definition\n\n\n\n2 Deletion & Change\n\nc: Change character or selection\nxd or dd: Delete line (remapped)\n:%d: Delete entire file\n\n\n\n3 File & Command Access\n\n&lt;Space&gt; f: File picker\n&lt;Space&gt; b: Buffer picker (all files in buffer)\n&lt;Space&gt; ?: Command palette\nZZ: Save and close\nZQ: Quit without saving\n:q: Quit\n\n\n\n4 Window Management\n\nCtrl-w v: Split window vertically\nzz: Center the current line on screen\n\n\n\n5 Selection\n\nv 2w: Select the next two words\nx: Expand selection downward\nX: Expand selection upward\n5x: Select current + 4 lines below\n2xv: Combine with jk to resize selection\nmi\": Select inside quotes\nmiw: Select inside word\nmip: Select inside paragraph\n%: Select entire file\n%s&lt;pattern&gt;: Select file and match pattern (regex supported); press Esc then , to exit multiple cursors\n&lt;Space&gt; /: Grep for word in current directory, then Ctrl+v to open matches in vertical split\n\n\n\n6 Multiple Cursors\n\nC: Duplicate cursor to the next match/line\n,: Remove the most recent cursor\nvj C C C: Select 2 lines and press C repeatedly to create multiple cursors every 2 lines\nCtrl+A / Ctrl+E: Move all cursors to start/end of line\nI / A: Enter insert mode across all cursors\n\n\n\n7 Copy & Paste\n\nx: Select line\np: Paste from register\n&lt;Space&gt; y: Copy selection to global register\n\n\n\n8 Commands\n\n| or Cmd+!: Pipe selection through shell command (e.g., | sort to sort lines)\n\n\n\n9 Definitions & Diagnostics\n\ngd: Go to definition\nCtrl+o: Go back to previous location\nCtrl+i: Go forward\n&lt;Space&gt; k: Show function help"
  },
  {
    "objectID": "commandline/coverpage.html",
    "href": "commandline/coverpage.html",
    "title": "Command Line Tools",
    "section": "",
    "text": "Transform Your Terminal with Ghostty and Yazi - Ready your terminal emulator and file manager\nEssential Helix Commands - Useful Helix commands"
  },
  {
    "objectID": "programming/coverpage.html",
    "href": "programming/coverpage.html",
    "title": "Programming",
    "section": "",
    "text": "Understanding Jacobian Adjustments for Constrained Parameters in Stan - A simple example to illustrate how Jacobian adjustment works in Stan"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "",
    "text": "pip3 install visidata\nvd --version"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#adjusting-columns",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#adjusting-columns",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.1 Adjusting Columns",
    "text": "5.1 Adjusting Columns\n\nHide a column: -\nShow all hidden columns: gv\nAuto-adjust column width: _"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#adding-columns-and-rows",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#adding-columns-and-rows",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.2 Adding Columns and Rows",
    "text": "5.2 Adding Columns and Rows\n\nza: Append a blank column\ni: Insert new column\n^: Rename column\na: Add a new row (not editable in frequency table)\nDelete a column: Shift+C, then d\nEdit a cell: e"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#navigation",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#navigation",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.3 Navigation",
    "text": "5.3 Navigation\n\nGo to beginning of column: gh\nGo to end of column: gl"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#overview-summary",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#overview-summary",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.4 Overview / Summary",
    "text": "5.4 Overview / Summary\n\nShift+I: Overview (‚Äúbird‚Äôs eye view‚Äù) of the data"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#selecting-and-deselecting-rows",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#selecting-and-deselecting-rows",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.5 Selecting and Deselecting Rows",
    "text": "5.5 Selecting and Deselecting Rows\n\n,: Select rows matching the current cell in the current column\ns: Select row\ngs: Select all\nu: Deselect current row\ngu: Deselect all\ngd: Delete all selected rows\nSelect by pattern:\nUse / to search column\nUse g/ to search all columns\nUse regex with \\... to deselect (e.g., rows longer than 3 chars)\nFrom frequency table:\n\nSelect rows (s), press g+Enter to go back\nUse \" to copy\nAlternative: Shift+F ‚Üí select rows ‚Üí q to go back"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#filtering",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#filtering",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.6 Filtering",
    "text": "5.6 Filtering\n\nz|: Filter rows using expressions\nExamples:\n\nOPERATOR == \"BUSINESS\"\nSTATE != \"FL\"\nHeight &gt; 170"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#deleting",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#deleting",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.7 Deleting",
    "text": "5.7 Deleting\n\nDelete row: d\nDelete column: Shift+C ‚Üí d\nDelete all selections: gd"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#replace-values",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#replace-values",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.8 Replace Values",
    "text": "5.8 Replace Values\n\nSelect matching rows with ,\nge: Globally edit selected cells in a column"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#sorting",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#sorting",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.9 Sorting",
    "text": "5.9 Sorting\n\nSort ascending: [\nSort descending: ]"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#plotting",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#plotting",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.10 Plotting",
    "text": "5.10 Plotting\n\nSelect x-axis column: !\nSelect y-axis column: !\nOptional: select color column\nEnsure cursor is on y-axis (numeric)\nPlot: .\nAdjust aspect ratio: z_ (plot width / height)\nConvert to numeric: % or #"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#command-prompt",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#command-prompt",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.11 Command Prompt",
    "text": "5.11 Command Prompt\n\nSpace: Launch command prompt"
  },
  {
    "objectID": "commandline/visidata-commands-tricks/visidata-commands.html#mnemonics",
    "href": "commandline/visidata-commands-tricks/visidata-commands.html#mnemonics",
    "title": "VisiData: Commands, Tips, and Tricks",
    "section": "5.12 Mnemonics",
    "text": "5.12 Mnemonics\n\ng = ‚Äúglobal‚Äù or ‚Äúall‚Äù:\n/ = search in column\ng/ = search in all columns\nz = ‚Äúzoom in‚Äù or ‚Äúnarrow‚Äù:\ny = copy column\nzy = copy cell"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "",
    "text": "Clone the dotfiles and copy the Neovim config into your ~/.config directory:\n\ngit clone https://github.com/JakeJing/dotfiles.git\nmv dotfiles/.config/nvim -P ~/.config/\n\nOpen plugins.lua and type :w to launch the auto-installation.\nUse :checkhealth to verify that all dependencies are properly set up."
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#installation",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#installation",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "",
    "text": "Clone the dotfiles and copy the Neovim config into your ~/.config directory:\n\ngit clone https://github.com/JakeJing/dotfiles.git\nmv dotfiles/.config/nvim -P ~/.config/\n\nOpen plugins.lua and type :w to launch the auto-installation.\nUse :checkhealth to verify that all dependencies are properly set up."
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#navigation-movements",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#navigation-movements",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "2 Navigation & Movements",
    "text": "2 Navigation & Movements\n\nhjkl: move left, down, up, right\nCtrl+d/u: scroll down/up one page\nCtrl+n/p: next/previous file in window\ni/I: insert before cursor / at line start\na/A: append after cursor / at line end\n0 / ^: go to line start\n$: go to line end\no/O: new line below/above\n%: jump between matching brackets\nb/e/w: word navigation (back, end, next)\nf{x} / F{x}: move to char {x} forward/back\nt{x} / T{x}: move before char {x} forward/back\n'' or g:: go back to previous position\no (in visual mode): toggle selection endpoint"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#bookmarks-with-telescope",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#bookmarks-with-telescope",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "3 Bookmarks (with Telescope)",
    "text": "3 Bookmarks (with Telescope)\n\nmm: toggle bookmark\nShift+n: next bookmark\nShift+b: previous bookmark\nma: view all bookmarks\n:Telescope vim_bookmarks all: list all bookmarks\n:Telescope vim_bookmarks current_file: list for current file"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#deleting-text",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#deleting-text",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "4 Deleting Text",
    "text": "4 Deleting Text\n\ndd: delete line\n3dd: delete 3 lines\nD or d$: delete to line end\nd0: delete to line start\nx: delete character under cursor\ndw, diw, daw: delete word (various scopes)\ndip: delete paragraph\ndi\": delete inside quotes\n:%d: delete entire file content\nci\" / ci(: delete and insert inside quotes/brackets"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#joining-lines",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#joining-lines",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "5 Joining Lines",
    "text": "5 Joining Lines\n\nJ: join lines with space\ngJ: join lines without space"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#increment-numbers",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#increment-numbers",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "6 Increment Numbers",
    "text": "6 Increment Numbers\n\nSelect numbers with Ctrl+v, then g Ctrl+a to increment"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#word-count",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#word-count",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "7 Word Count",
    "text": "7 Word Count\n\n:WordCount: custom word count (requires user-defined function)\n&lt;leader&gt;wc: shortcut for word count"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#selection-visual-mode",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#selection-visual-mode",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "8 Selection (Visual Mode)",
    "text": "8 Selection (Visual Mode)\n\nv, V, Ctrl+v: character, line, and block selection\nviw, vaw: inside/around word\nvi{: inside block (like function)\nf{char} in visual mode: fast selection"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#multi-line-insert-append",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#multi-line-insert-append",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "9 Multi-line Insert & Append",
    "text": "9 Multi-line Insert & Append\n\nNote: Only works in visual block mode (Ctrl+v).\n\n\nInsert start: Ctrl+v, select, Shift+i, type, then Esc\nAppend end: Ctrl+v, select, Shift+a, type, then Esc\nChange text: select block, press c, type, then Esc"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#editing-text",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#editing-text",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "10 Editing Text",
    "text": "10 Editing Text\n\nci(: change inside parentheses\ncip: change inside paragraph\ncw: change word"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#yank-paste",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#yank-paste",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "11 Yank & Paste",
    "text": "11 Yank & Paste\n\nyy, yiw, ya(, y2w: yank lines, words, brackets\nUse neoclip for yank history:\n\n&lt;C-c&gt; to yank\n&lt;C-p&gt; to paste from history"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#substitution",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#substitution",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "12 Substitution",
    "text": "12 Substitution\n\nS: start substitution (:%s//g via remap)\ncgn: change next match, repeat with .\nRegex substitution:\n:%s/[-.+/a-zA-Z0-9\"$]*\\ze:/`\\0`/g\nR: overwrite text\n:'&lt;,'&gt;s/old/new/g: substitute in selection\n:cdo s/old/new/g: substitute across quickfix list"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#repeating-undoing",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#repeating-undoing",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "13 Repeating & Undoing",
    "text": "13 Repeating & Undoing\n\n.: repeat last change\nu / U: undo / undo line\nCtrl+r: redo\nCtrl+s: open terminal in vertical split\n:vs | :term: open vertical terminal"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#quit-save",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#quit-save",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "14 Quit & Save",
    "text": "14 Quit & Save\n\nZZ: save and quit\nZQ: quit without saving"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#key-mapping-help",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#key-mapping-help",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "15 Key Mapping & Help",
    "text": "15 Key Mapping & Help\n\n15.1 Special Keys\n&lt;Tab&gt;, &lt;CR&gt;, &lt;Esc&gt;, &lt;Space&gt;, &lt;A-j&gt;, &lt;C-s&gt;, &lt;Up&gt;, &lt;F1&gt;...&lt;F12&gt;, etc.\n\n\n15.2 Check Mappings\n:imap &lt;A-j&gt;\n:verbose imap &lt;Tab&gt;\n\n\n15.3 Help\n\n:h {key} or :help ctrl-w_&lt;\n:h telescope.command, :h regex\nfh or &lt;leader&gt;fh: floating help"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#terminal-tricks",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#terminal-tricks",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "16 Terminal Tricks",
    "text": "16 Terminal Tricks\n\nCtrl+s: toggle floating terminal\n:r !ls: insert output of shell command"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#termvifm-zoxide",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#termvifm-zoxide",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "17 TermVifm + Zoxide",
    "text": "17 TermVifm + Zoxide\n\nBind vf to launch vifm\nUse zoxide with &lt;leader&gt;Z to jump to dirs\n\nInstall with brew install zoxide\nAdd to config.fish:\nzoxide init fish | source"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#search",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#search",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "18 Search",
    "text": "18 Search\n\nff: find file\nfa: find all in buffer\nfw: find word\n'Search: exact match\n:set hlsearch / :nohlsearch: toggle highlights"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#buffers",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#buffers",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "19 Buffers",
    "text": "19 Buffers\n\n:bfirst, :blast, :bnext, :bprevious\n:ls: list buffers\n:bd [num]: close buffer\n:b &lt;TAB&gt;: autocomplete open buffers\nCtrl+^: toggle last buffer"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#window-management",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#window-management",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "20 Window Management",
    "text": "20 Window Management\n\nCtrl+w w: switch windows\nCtrl+w h/l: left/right\nCtrl+w _: maximize\nCtrl+w =: equalize\nCtrl+w R: reverse splits\nCtrl+w t Ctrl+w K: horizontal ‚Üí vertical\nCtrl+w t Ctrl+w H: vertical ‚Üí horizontal\nCtrl+Cmd+F or fn+F: full screen"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#git-with-lazygit",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#git-with-lazygit",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "21 Git with LazyGit",
    "text": "21 Git with LazyGit\n\nCtrl+g: open LazyGit\nc: commit\nShift+p: push\n?: help\ngl: git logs"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#linting-formatting",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#linting-formatting",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "22 Linting & Formatting",
    "text": "22 Linting & Formatting\n\n:NullLsInfo: see current null-ls status\n:echo executable(\"eslint\"): check if installed\n:LspStop: stop diagnostics"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#registers-special-characters",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#registers-special-characters",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "23 Registers & Special Characters",
    "text": "23 Registers & Special Characters\n\"%\": current file\n\"#\": alternate file\n\"*\", \"+\": system clipboard\n\"/\": last search\n\":\": last command\n\"-\": last small delete\n\".\": last insert\n\"=\": expression register"
  },
  {
    "objectID": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#cmdline-modes",
    "href": "commandline/nvim-cheatsheet/nvim-cheatsheet.html#cmdline-modes",
    "title": "Neovim Cheat Sheet: Essential Tricks and Shortcuts",
    "section": "24 Cmdline Modes",
    "text": "24 Cmdline Modes\n:   Normal command\n&gt;   Debug mode\n/   Forward search\n?   Backward search\n=   Expression\n@   Input()\n-   Insert/append text\n\nq:: show command history"
  }
]